[TOC]

<font color=red>⚠️</font>：较难

♨️：中等

❗：易错题

⚡：较难理解



## 字符串

### NC52 有效括号序列

与左括号匹配的右括号应该符合先进后出原理：最外层的括号即最早出现的左括号，也对应最晚出现的右括号，即先进后出，因此可以使用同样先进后出的栈：遇到左括号就将相应匹配的右括号加入栈中，后续如果是合法的，右括号来的顺序就是栈中弹出的顺序。

**具体做法：**

- step 1：创建辅助栈，遍历字符串。
- step 2：每次遇到小括号的左括号、中括号的左括号、大括号的左括号，就将其对应的右括号加入栈中，期待在后续遇到。
- step 3：如果没有遇到任何左括号且栈为空，说明直接遇到了右括号，不合法。
- step 4：其他情况下，如果遇到右括号，刚好与栈顶元素相同，弹出栈顶元素继续遍历。
- step 5：理论上，只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判断是否合法。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return bool布尔型
#
class Solution:
    def isValid(self , s: str) -> bool:
        st = [] # 辅助栈

        for i, char in enumerate(s):
            if char == '(':
                st.append(')')
            elif char == "[":
                st.append(']')
            elif char =='{':
                st.append('}')
            # 如果以上都没有遇到，且st为空,说明直接遇到了右括号(因为这里枚举了，所以直接排除了s为空的情况)
            elif(len(st) == 0):
                return False
            # st不为空，那么如果右括号匹配
            elif(st[-1] == char):
                st.pop()
        return len(st)==0
```

### ♨️NC1 大数加法

如何用字符串计算加法。

- step 1：若是其中一个字符串为空，直接返回另一个。
- step 2：交换两个字符串的位置，让s为较长的字符串，t为较短的字符串，结果也记录在较长的字符串中。
- step 3：从后往前遍历字符串s，每次取出字符转数字，加上进位数，将下标转换为字符串t中从后往前相应的下标，如果下标为非负数（t还有）则还需要加上字符串t中相应字符转化的数字。
- step 4：/取进位，%取余数，将计算后的结果放入较长数组对应位置。
- step 5：如果遍历结束，进位值还有，则需要直接在字符串s前增加一个字符‘1’。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算两个数之和
# @param s string字符串 表示第一个整数
# @param t string字符串 表示第二个整数
# @return string字符串
#
class Solution:
    def solve(self , s: str, t: str) -> str:
        # 一个为空，直接返回另一个
        if len(s) == 0:
            return t
        if len(t) == 0:
            return s
        # 让s为较长的，t为较短的
        if len(s) < len(t):
            temp = t
            t = s
            s = temp

        i = len(s) - 1
        carry = 0 # 进位标志

        #从后往前遍历较长的字符串
        while i >= 0:
            temp = ord(s[i])- ord('0') + carry # 先转ascii码然后与0的相减获得数字
            j = i - len(s) + len(t) # 较短字符的下标
            # 如果较短字符串还有,转数组相加
            if j>= 0:
                temp += ord(t[j])-ord('0')
            carry = int(temp / 10) # 进位
            temp = temp % 10 # 去10位
            s = s[:i] + chr(temp + ord('0')) + s[i+1:] # 把s拼装起来,进位在进入循环的第一步就考虑了
            i -= 1
        #最后的进位
        if carry == 1:
            s = '1' + s
        return s
```

### ♨️NC127 最长公共子串

在长字符串内循环查找，维护一个最大长度。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# longest common substring
# @param str1 string字符串 the string
# @param str2 string字符串 the string
# @return string字符串
#
class Solution:
    def LCS(self , str1: str, str2: str) -> str:
        # 让str1为较长的字符串
        if len(str1) < len(str2):
            str1, str2 = str2, str1
        res = ''
        max_len = 0
        for i in range(len(str1)):
        	# 每次查找str1中max_len+1长度的字符串在str2中是否有，有的话max_len+1，然后下次再接着找+1长度的字符串
            if str1[i-max_len : i+1] in str2: 
                res = str1[i-max_len : i+1]
                max_len += 1
        return res
```

### NC103 反转字符串

方法一：开辟新的字符串，然后倒序赋值。

方法二：双指针前后交换。

下面是方法一的代码。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 反转字符串
# @param str string字符串 
# @return string字符串
#
class Solution:
    def solve(self , str: str) -> str:
        res = ''
        num = len(str)
        for i in range(num):
            res += str[num-1-i]
        return res
```

### NC17 最长回文子串

回文串，指左右对称的字符串。回文字符串分奇数对称和偶数对称，遍历每个字符，将其作为对称中心往外扩张，维护一个长度最大值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param A string字符串 
# @return int整型
#
class Solution:
    def fun(self, s: str, begin: int, end: int):
        while begin >=0 and end < len(s) and s[begin] == s[end]:
            begin -= 1
            end += 1
        return end-begin-1 # 注意：退出循环的时候begin和end包裹了回文字符串，所以应该-1
    def getLongestPalindrome(self , A: str) -> int:
        maxlen = 1
        for i in range(0, len(A)-1): # -1因为要搜到i+1
            # 回文字符串分奇数长度和偶数长度，偶数长度时只有两个连续一样的才可能是
            maxlen = max(maxlen, max(self.fun(A, i, i), self.fun(A, i, i+1)))
        return maxlen
```

### NC141 判断是否为回文字符串

字符串回文指该字符串正序与其逆序逐字符一致。双指针遍历判断前后是否相等。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str string字符串 待判断的字符串
# @return bool布尔型
#
class Solution:
    def judge(self , str: str) -> bool:
        left, right = 0, len(str) - 1
        while left < right:
            if str[left] == str[right]:
                left += 1
                right -= 1
            else:
                return False
        return True
```



### ⚡♨️NC121 字符串的排列

递归法。

每选取一个字符以后，就确定了其位置，相当于对字符串中剩下的元素进行全排列添加在该元素后面，给剩余部分进行全排列就是一个**子问题**，因此可以使用**递归**。

- **终止条件：** 临时字符串中选取了n个元素，已经形成了一种排列情况了，可以将其加入输出数组中。
- **返回值：** 每一层给上一层返回的就是本层级在临时字符串中添加的元素，递归到末尾的时候就能添加全部元素。
- **本级任务：** 每一级都需要选择一个元素加入到临时字符串末尾（遍历原字符串选择）。

递归过程也需要回溯，比如说对于字符串`“abbc”`，如果事先在临时字符串中加入了a，后续子问题只能是`"bbc"`的全排列接在a后面，对于b开头的分支达不到，因此也需要回溯：将临时字符串刚刚加入的字符去掉，同时vis修改为没有加入，这样才能正常进入别的分支。

**具体做法：**

- step 1：先对字符串按照字典序排序，获取第一个排列情况。
- step 2：准备一个空串暂存递归过程中组装的排列情况。使用额外的vis数组用于记录哪些位置的字符被加入了。
- step 3：每次递归从头遍历字符串，获取字符加入：首先根据vis数组，已经加入的元素不能再次加入了；同时，如果当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用，也不需要将其纳入。
- step 4：进入下一层递归前将vis数组当前位置标记为使用过。
- step 5：回溯的时候需要修改vis数组当前位置标记，同时去掉刚刚加入字符串的元素，
- step 6：临时字符串长度到达原串长度就是一种排列情况

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str string字符串 
# @return string字符串一维数组
#
class Solution:
    def recursion(self, res: List[str], string: str, temp: str, vis:List[int]):
        # 临时字符串已经加入了所有的字符，直接输出
        if len(temp) == len(string):
            res.append(temp)
            return
        for i in range(len(string)):
            # 如果元素已经被加入了则不需要再加入了
            if vis[i] == 1:
                continue
            # 当前的元素与 *同层的* 前一个元素str[i-1]相同且str[i-1]已经用过了也不用加入
            # 我理解是：像abb，a在temp里会有abb(23)和abb(32)两种重复排列，因此这里去掉了abb(23)，保留了abb(32)
            if i>0 and string[i-1] == string[i] and vis[i-1]:
                continue
            # 标记为使用过,并加入临时字符串
            vis[i] = 1
            temp += string[i]
            self.recursion(res, string, temp, vis)
            # 回溯
            vis[i] = 0
            temp = temp[:-1]


    def Permutation(self , str: str) -> List[str]:
        # 先按字典序排序，使重复字符串相邻
        str = "".join((lambda x:(x.sort(),x)[1])(list(str)))
        res = []
        temp = ""
        # 标记每个位置的字符是否被使用过
        vis = [0]*len(str) #乘号是扩展成[0,0,...,0]
        # 递归获取
        self.recursion(res, str, temp, vis)
        return res
```





## 链表

### NC78 反转链表

注意最后循环到 cur = none，返回的是 pre。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        pre = None # 定义空节点
        cur = head # 当前节点
        while cur: # 循环后移，直至不为none
            temp = cur.next # 暂时保留下一个即将翻转的节点
            cur.next = pre # 翻转当前节点
            pre = cur # pre后移
            cur = temp #cur后移
        return pre
```

### NC33 合并两个排序的链表

双指针迭代法：使用归并排序的思想，每次比较两个头部，从中取出小的元素，然后依次往后，这需要两个指针同方向访问才能实现。双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针），从而达到我们需要的目的。

- step 1：判断空链表的情况，只要有一个链表为空，那答案必定就是另一个链表了，就算另一个链表也为空。
- step 2：新建一个空的表头后面连接两个链表排序后的节点，两个指针分别指向两链表头。
- step 3：遍历两个链表都不为空的情况，取较小值添加在新的链表后面，每次只把被添加的链表的指针后移。
- step 4：遍历到最后肯定有一个链表还有剩余的节点，它们的值将大于前面所有的，直接连在新的链表后面即可。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self , pHead1: ListNode, pHead2: ListNode) -> ListNode:
        if pHead1 == None:
            return pHead2
        if pHead2 == None:
            return pHead1
        
        head = ListNode(0) # 新建表头
        cur = head

        while pHead1 and pHead2: # 均不为空
            if pHead1.val <= pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 = pHead2.next
            cur = cur.next

        # 如果有链表有剩余,直接连在后面
        if pHead1:
            cur.next = pHead1
        if pHead2:
            cur.next = pHead2
        return head.next # 返回时去掉表头
```

### NC51 合并k个已排序的链表

根据上题合并两个有序链表的思路，也可以遍历链表数组，两两比较合并。但是这样太浪费时间了。

采用**归并+分治**来做，将k个链表每次划分成等长的两大部分，对两部分进行合并排序即是子问题。对子问题继续划分，直到子问题只有1个元素。还原的时候子问题就是合并两个有序链表，直到合并成原本长度的数组。

ps：分治即“分而治之”，“分”指的是将一个大而复杂的问题划分成多个性质相同但是规模更小的子问题，子问题继续按照这样划分，直到问题可以被轻易解决；“治”指的是将子问题单独进行处理。经过分治后的子问题，需要将解进行合并才能得到原问题的解，因此整个分治过程经常用递归来实现。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param lists ListNode类一维数组 
# @return ListNode类
#
class Solution:
    # NC33合并两个有序链表
    def Merge(self, pHead1: ListNode, pHead2: ListNode):
        if pHead1 == None:
            return pHead2
        if pHead2 == None:
            return pHead1
        
        head = ListNode(0)
        cur =  head

        while pHead1 and pHead2:
            if pHead1.val <= pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 = pHead2.next
            cur =  cur.next
        if pHead1:
            cur.next = pHead1
        if pHead2:
            cur.next = pHead2
        return head.next

    # 把k个有序链表的合并不断分治，变成两两合并
    def divideMerge(self, lists: ListNode, left: int, right: int):
        if left > right:
            return None
        elif left == right:
            return lists[left]
        mid = int(left + (right-left)/2)
        return self.Merge(self.divideMerge(lists, left, mid), self.divideMerge(lists, mid+1, right))
  
    def mergeKLists(self , lists: List[ListNode]) -> ListNode:
        return self.divideMerge(lists, 0, len(lists)-1)
```

### NC70 单链表的排序

递归+归并排序。把链表分两部分，每部分排好序然后再合并。那么就相当于递归+合并两个有序链表（nc33）。

关键点是链表怎么找中间元素？——快慢双指针，快指针每次两步，慢指针每次一步，当快指针到达链表尾的时候，慢指针正好走了快指针距离的一半，为中间元素。

**具体做法：**

- step 1：首先判断链表为空或者只有一个元素，直接就是有序的。
- step 2：准备三个指针，快指针right每次走两步，慢指针mid每次走一步，前序指针left每次跟在mid前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针mid刚好走了链表的一半，正好是中间位置。
- step 3：从left位置将链表断开，刚好分成两个子问题开始递归。
- step 4：将子问题得到的两个有序链表合并。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 the head node
# @return ListNode类
#
class Solution:
    # nc33合并两个有序链表，双指针
    def merge(self, pHead1: ListNode, pHead2: ListNode):
        if pHead1 == None:
            return pHead2
        if pHead2 == None:
            return pHead1
        
        head = ListNode(0) # 新建表头
        cur = head

        while pHead1 and pHead2: # 均不为空
            if pHead1.val <= pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 = pHead2.next
            cur = cur.next

        # 如果有链表有剩余,直接连在后面
        if pHead1:
            cur.next = pHead1
        if pHead2:
            cur.next = pHead2
        return head.next # 返回时去掉表头

    def sortInList(self , head: ListNode) -> ListNode:
        # 链表为空或者只有一个元素，直接就是有序的
        if head == None or head.next == None:
            return head
        left = head
        mid = head.next
        right = head.next.next
        while right and right.next: # 注意条件，必须要有两项，只有while right.next那么尾节点后面的每个空节点都满足
            left = left.next
            mid = mid.next
            right = right.next.next
        # 从left和mid中间断开
        left.next = None
        return self.merge(self.sortInList(head), self.sortInList(mid))
```

### ♨️NC50 链表中的节点每k个一组翻转

- step 1：每次从进入函数的头节点优先遍历链表k次，分出一组，若是后续不足k个节点，不用反转直接返回头。
- step 2：从进入函数的头节点开始，依次反转接下来的一组链表。
- step 3：这一组经过反转后，原来的头变成了尾，后面接下一组的反转结果，下一组采用上述递归继续。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def reverseKGroup(self , head: ListNode, k: int) -> ListNode:
        tail = head
        for i in range(0, k):
            if tail == None:
                return head # 如果不足k到了链表尾，直接返回，不翻转
            tail = tail.next

        #翻转时需要的前序和当前节点
        pre = None
        cur = head  
        while cur != tail:  # 在到达当前段尾节点前
            # 翻转
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
            #当前尾连接下一段翻转的首
        head.next = self.reverseKGroup(tail, k)
        return pre 
```

### NC4 判断链表中是否有环

快慢双指针。快指针每次走2步，慢指针每次走1步，如果没有环快指针会先一步找到NULL节点，如果有环两指针的速度差会让它们相遇。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        if head == None:
            return False
        
        fast, slow = head, head

        while fast!= None and fast.next != None: # 如果没环快指针会先到链表尾
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

### NC3 链表中环的入口节点

快慢双指针判断是否有环（参考上题）+环入口节点检测。

假定是一个有环链表，那么怎么找到环的入口呢？在慢指针进入链表环之前，快指针已经进入了环，且在里面循环。不妨假设快指针在环中走了n圈，慢指针在环中走了m圈后相遇，而进入环之前的距离为x，环入口到相遇点的距离为y，相遇点到环入口的距离为z。快指针一共走了x+n(y+z)+y步，慢指针一共走了x+m(y+z)+y。由于快指针走的倍数是慢指针的两倍，则x+n(y+z)+y=2(x+m(y+z)+y)，即x+y=(n−2m)(y+z)。因为环的大小是y+z，说明从链表头经过环入口到达相遇地方经过的距离等于整数倍环的大小。那**从头开始遍历到相遇位置，和从相遇位置开始在环中遍历，步数是一样的，而双方最后都会经过入口到相遇位置这y个节点，那说明这y个节点它们就是重叠遍历的，一开始在环入口位置就相遇了，这就找到了环入口**。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        if head == None:
            return False
        
        fast, slow = head, head

        while fast!= None and fast.next != None: # 如果没环快指针会先到链表尾
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

### NC53 删除链表的倒数第n个节点

如何逆序遍历链表：快慢指针。需要注意链表头被删除的情况！快慢指针相距n个节点，当快指针走到尾节点，慢指针就找到了要删除的节点。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def removeNthFromEnd(self , head: ListNode, n: int) -> ListNode:
        # 保存链表头，防止原先的表头被删掉
        res = ListNode(0)
        res.next = head

        pre = res
        slow, fast = head, head
        
        for i in range(n):
            fast = fast.next
        while fast:
            fast = fast.next    
            pre = pre.next
            slow =  slow.next
        # 删除slow
        pre.next = slow.next

        return res.next
```

### NC66 两个链表的第一个公共节点

双指针法。两链表长度不同，但a+b作为链表A的新长度，b+a作为链表B的新长度，就保证了两个链表从头节点到公共节点的路径一样长，只需要双指针遍历判断是否遇到公共节点即可。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def FindFirstCommonNode(self , pHead1 , pHead2 ):
        # write code here
        pa = pHead1
        pb = pHead2
        while pa != pb:
            pa = pa.next if pa else pHead2
            pb = pb.next if pb else pHead1
        # 退出循环要么找到了共同节点，要么pa,pb都走到了结尾
        return pa
```

### ❗NC40 链表相加（二）

双指针法。两链表长度不同，但a+b作为链表A的新长度，b+a作为链表B的新长度，就保证了两个链表从头节点到公共节点的路径一样长，只需要双指针遍历判断是否遇到公共节点即可。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head1 ListNode类 
# @param head2 ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self, pHead: ListNode):
        if pHead == None:
            return None
        cur = pHead
        pre = None
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

    def addInList(self , head1: ListNode, head2: ListNode):
        if head1 == None:
            return head2
        if head2 ==None:
            return head1
        # 反转两个链表
        head1 = self.ReverseList(head1)
        head2 = self.ReverseList(head2)
        # 添加表头节点
        res = ListNode(-1)
        head = res
        carry = 0
        # 只要某个链表还有或者进位还有
        while head1 != None or head2 != None or carry != 0:
            val1 = 0 if head1 == None else head1.val
            val2 = 0 if head2 == None else head2.val
            temp = val1 + val2 + carry
            # 获取进位
            carry = (int)(temp / 10)  # !!!!!!一定要int，不然会变成小数，报错
            temp = temp % 10
            # 在返回链表的头节点后添加节点
            head.next = ListNode(temp)
            head = head.next
            # 移动下一个
            if head1:
                head1 = head1.next
            if head2:
                head2 = head2.next
        return self.ReverseList(res.next)
```

### 

## 哈希

### ⚠️NC93 设计LRU（最近最少使用）缓存结构

哈希表（保存key和链表节点）+双向链表（保存key和value）。

```
# 构建双向链表
class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.pre = None
        self.next = None

class Solution:

    def __init__(self, capacity: int):
        self.size = capacity
        # 双向链表头尾
        # self.head = None
        # self.tail = None
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.pre = self.head
        # 哈希表
        self.mp = dict()

    def get(self, key: int) -> int:
        res = -1 #找不到返回-1
        #哈希表中找到
        if key in self.mp:
            res = self.mp[key].val
            self.moveToHead(self.mp[key])
        return res

    def removeLast(self):
        # 哈希去掉key
        self.mp.pop(self.tail.pre.key) # tail的pre指向最后一个节点
        # 链表去掉节点
        self.tail.pre.pre.next = self.tail
        self.tail.pre = self.tail.pre.pre

    def insertFirst(self, node: Node):
        node.pre = self.head
        node.next = self.head.next
        self.head.next.pre = node
        self.head.next = node

    def moveToHead(self, node: Node):
        # 已经到了表头
        if node.pre != self.head:
            # 节点断开取出
            node.pre.next = node.next
            node.next.pre = node.pre
            # 节点插入
            self.insertFirst(node)

    def set(self, key: int, value: int) -> None:
        # 插入新值
        if key not in self.mp:
            node = Node(key, value) # 新建链表节点
            self.mp[key] = node
            # 如果超出大小，移除最后一个，否则直接插入
            if self.size <= 0:
                self.removeLast()
            else:
                self.size -= 1
            self.insertFirst(node)
        # 哈希表中已经这个key
        else:
            self.mp[key].val =  value
            # 更新链表，移到表头
            self.moveToHead(self.mp[key])
        return "null"

             
# Your Solution object will be instantiated and called as such:
# solution = Solution(capacity)
# output = solution.get(key)
# solution.set(key,value)
```



## 排序

### NC140 排序（数组升序排序）

```
class Solution:
    def MySort(self , arr: List[int]) -> List[int]:
        # 快速排序：选一个基准值，让左边值的都比它小，右边的值都比它大。
        #          然后在左边和右边重复选择基准值、排序。
        #          时间复杂度O(nlogn), 空间复杂度O(1)
        self.quick_sort(0, len(arr)-1, arr)
        return arr

    def quick_sort(self, start, end , arr):
        if start < end:
            left, right = start, end
            pivot = arr[(start + end)//2]

            while left <= right: # 一次排序，循环结束条件right < left
                while left <= right and arr[left] < pivot: # 找到左边第一个比基准值大的
                    left += 1
                while left <= right and arr[right] > pivot: # 找到右边第一个比基准值小的
                    right -=1
                
                if left <= right:
                    arr[left], arr[right] = arr[right], arr[left] # 左右交换
                    left += 1
                    right -= 1
            
            self.quick_sort(start, right, arr) # 左边继续循环
            self.quick_sort(left, end, arr) # 右边继续循环
```

### NC119 最小的k个数

堆就是用数组表示的二叉树，分为大根堆和小根堆，大根堆为堆顶元素最大的堆，小根堆为堆顶元素最小的堆。

- step 1：利用input数组中前k个元素，构建一个大小为k的大顶堆，堆顶为这k个元素的最大值。
- step 2：对于后续的元素，依次比较其与堆顶的大小，若是比堆顶小，则堆顶弹出，再将新数加入堆中，直至数组结束，保证堆中的k个最小。
- step 3：最后将堆顶依次弹出即是最小的k个数。

```
# 
# @param input int整型一维数组 
# @param k int整型 
# @return int整型一维数组
#
import heapq # heapq提供了对堆的支持, 最重要的特征是heap默认建立小根堆,heap[0]最小

class Solution:
    def GetLeastNumbers_Solution(self , input: List[int], k: int) -> List[int]:
        res = []

        if len(input) >= k and k != 0:
            pq = []
            for i in range(k):
                heapq.heappush(pq, (-1 * input[i])) # *-1用于建立大根堆
            for i in range(k, len(input)):
                if (-1 * pq[0]) > input[i]:
                    heapq.heapreplace(pq, (-1 * input[i])) #弹出并返回pq中最小值，同时推入新值

            for i in range(k):
                res.append(-1 * pq[0])
                heapq.heappop(pq) #弹出并返回pq的最小的元素，保持堆的不变性。
        return res
```

### ❗NC88 寻找第k大

两种方法：快排+二分或者小根堆。注意！是第k大，要找最大的k个数里的最小值！！！

1. 快排+二分：先快排，然后每次循环后判断右侧有没有k-1个值，如果有说明当前标杆正是要找的，如果小于k-1，那么只需要再对左边快排，反之右边。写了一下好像超时了？
2. 小根堆：参考上一题，但注意是小根堆

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param a int整型一维数组 
# @param n int整型 
# @param K int整型 
# @return int整型
#
import heapq
class Solution:
    def findKth(self , a: List[int], n: int, K: int) -> int:
        res = a[0]
        if K > 0:
            pq = []
            for i in range(K):
                heapq.heappush(pq, ( a[i])) # 用于建立小根堆
            for i in range(K, n):
                if pq[0] < a[i]:
                    heapq.heapreplace(pq,  a[i]) #弹出并返回pq中最小值，同时推入新值

            res = heapq.heappop(pq)
        return res
```

## 

## 二叉树

### ♨️NC45 实现二叉树先序，中序和后序遍历

遍历递归或栈，下面是递归解法。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 the root of binary tree
# @return int整型二维数组
#
class Solution:
    def threeOrders(self , root: TreeNode) -> List[List[int]]:
        self.res = [[], [], []]
        self.dfs(root)
        return self.res

    def dfs(self, root):
        if root: # root不空
            self.res[0].append(root.val) # 先序：根左右
            self.dfs(root.left)
            self.res[1].append(root.val) # 中序：左根右
            self.dfs(root.right)
            self.res[2].append(root.val) # 后序：左右根
```

### ♨️NC12 重建二叉树

根据二叉树的前序和中序，重建二叉树返回根节点。

<img src="/home/chuyun/Downloads/personal/Offer_log/nc12.png" style="zoom:65%;" />

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        if len(pre) == 0 or len(vin) == 0:
            return None # 这里必须是none
        root = TreeNode(pre[0])
        for i in range(len(vin)):
            if vin[i] == pre[0]:
                # 找到左子树的前序和中序遍历，并递归构建左子树
                leftpre = pre[1:i+1]
                leftvin = vin[:i]
                root.left = self.reConstructBinaryTree(leftpre, leftvin)
                # 找到右子树的前序和中序遍历，并递归构建右子树
                rightpre = pre[i+1:]
                rightvin = vin[i+1:]
                root.right = self.reConstructBinaryTree(rightpre, rightvin)
                # break 加不加都能通过提交
        return root
```

### ♨️NC15 二叉树的层序遍历

- 维护一个队列queue，保存每一层的所有结点
- 遍历每一层，从队列中逐个取出当前层的结点，并收集所有节点的值到集合temp
- 查询每个节点的左右节点，按顺序加到queue队尾，循环重复，直至队列长度为0

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
class Solution:
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        # 使用队列，先进先出。维护队列，存储每一层的节点值
        queue = []
        res = []
        if not root:
            return res
        queue.append(root)
        while len(queue) != 0:
            num = len(queue)
            temp = []
            # 遍历一层
            for i in range(num):
                node = queue.pop(0)
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(temp)
        return res
```

### ♨️NC136 输出二叉树的右视图

 根据先序和中序，输出二叉树右视图。先根据NC12重建，然后用层次遍历输出每层最右节点。

建树后也可以用dfs输出右视图，有点麻烦算了。。。。。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 求二叉树的右视图
# @param xianxu int整型一维数组 先序遍历
# @param zhongxu int整型一维数组 中序遍历
# @return int整型一维数组
#
class Solution: 
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        if len(pre) == 0 or len(vin) == 0:
            return None # 这里必须是none
        root = TreeNode(pre[0])
        for i in range(len(vin)):
            if vin[i] == pre[0]:
                # 找到左子树的前序和中序遍历，并递归构建左子树
                leftpre = pre[1:i+1]
                leftvin = vin[:i]
                root.left = self.reConstructBinaryTree(leftpre, leftvin)
                # 找到右子树的前序和中序遍历，并递归构建右子树
                rightpre = pre[i+1:]
                rightvin = vin[i+1:]
                root.right = self.reConstructBinaryTree(rightpre, rightvin)
                # break 加不加都能通过提交
        return root

    def rightview(self, root: TreeNode):
        # 使用队列，先进先出。维护队列，存储每一层的节点值
        queue = []
        res = []
        if not root:
            return res
        queue.append(root)
        while len(queue) != 0:
            num = len(queue)
            temp = []
            # 遍历一层
            for i in range(num):
                node = queue.pop(0)
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(temp[-1])
        return res      

    def solve(self , xianxu: List[int], zhongxu: List[int]) -> List[int]:
        if len(xianxu) == 0:
            return []
        # NC12重建二叉树
        root = self.reConstructBinaryTree(xianxu, zhongxu)
        # NC15层序遍历输出每层最右节点
        return self.rightview(root)
```

### ♨️NC14 按之字形顺序打印二叉树

 双栈。维护两个栈，一个存放奇数层的节点，一个存放偶数层的节点

- 奇数层按顺序，每次偶数层的栈保存偶数层节点，先存左结点，这样等下次pop时就是右节点先打印
- 偶数层反序，每次奇数层的栈保存偶数层节点，先存右结点，这样等下次pop时就是左节点先打印

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return int整型二维数组
#
class Solution:
    def Print(self , pRoot: TreeNode) -> List[List[int]]:
        res = []
        if not pRoot:
            return res
        stack1 = [pRoot] # 保存奇数层节点
        stack2 = [] # 保存偶数层节点

        while stack1 or stack2:
            res1 =[]
            res2 = []
            # 处理奇数层
            while stack1:
                node = stack1.pop()
                if node.left:
                    stack2.append(node.left)  # 利用栈先进后出
                if node.right:
                    stack2.append(node.right)
                res1.append(node.val)
            # 收集当前层的结果
            if len(res1) != 0:
                res.append(res1)
            # 处理偶数层
            while stack2:
                node = stack2.pop()
                if node.right:
                    stack1.append(node.right)
                if node.left:
                    stack1.append(node.left)
                res2.append(node.val)
            if len(res2) != 0:
                res.append(res2)
        
        return res
```

### ♨️NC102 在二叉树中找到两个节点的最近公共祖先

深度优先搜索

- step 1：利用dfs求得根节点到两个目标节点的路径：每次选择二叉树的一棵子树往下找，同时路径数组增加这个遍历的节点值。
- step 2：一旦遍历到了叶子节点也没有，则回溯到父节点，寻找其他路径，回溯时要去掉数组中刚刚加入的元素。
- step 3：然后遍历两条路径数组，依次比较元素值。
- step 4：找到两条路径第一个不相同的节点即是最近公共祖先。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param o1 int整型 
# @param o2 int整型 
# @return int整型
#
class Solution:
    # 记录是否找到到o的路径
    flag = False
    # 求根节点到目标节点的路径
    def dfs(self, root: TreeNode, path: List[int], o: int):
        if self.flag or not root:
            return
        path.append(root.val)
        if root.val == o:
            self.flag = True
            return
        # dfs遍历查找
        self.dfs(root.left, path, o)
        self.dfs(root.right, path, o)
        # 搜到叶子节点，如果找到
        if self.flag:
            return
        # 该子树没有，回溯上个节点，然后开始搜下颗树
        path.pop() 

    def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -> int:
        path1, path2 = [], []
        self.dfs(root, path1, o1)
        self.flag = False
        self.dfs(root, path2, o2)
        i = 0
        res = None
        # 比较两个路径，找到第一个不同的点
        while i < len(path1) and i < len(path2):
            if path1[i] == path2[i]:
                # 最后一个相同的节点是最近公共祖先
                res = path1[i]
                i += 1
            else:  # 找到不同的节点了，直接退出
                break
        return res
```

### NC13 二叉树的最大深度

dfs递归。最大深度是所有叶子节点的深度的最大值，深度是指树的根节点到任一叶子节点路径上节点的数量，因此从根节点每次往下一层深度就会加1。因此二叉树的深度就等于根节点这个1层加上左子树和右子树深度的最大值，即rootdepth = max( leftdepth, rightdepth )+1。而每个子树我们都可以看成一个根节点，继续用上述方法求的深度，于是我们可以对这个问题划为子问题，利用递归来解决：

- **终止条件：** 当进入叶子节点后，再进入子节点，即为空，没有深度可言，返回0.
- **返回值：** 每一级按照上述公式，返回两边子树深度的最大值加上本级的深度，即加1.
- **本级任务：** 每一级的任务就是进入左右子树，求左右子树的深度。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

### NC62 判断是不是平衡二叉树

**平衡二叉树**（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

循环每个节点，计算左右子数深度（nc13），判断是否平衡。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
	# 二叉树的最大深度nc13
    def deep(self, root: TreeNode):
        if not root:
            return 0
        left = self.deep(root.left)
        right = self.deep(root.right)
        return max(left, right) + 1
        
    def IsBalanced_Solution(self , pRoot: TreeNode) -> bool:
        # 空树
        if not pRoot:
            return True
        # 获取左右深度
        left = self.deep(pRoot.left)
        right = self.deep(pRoot.right)
        # 深度相差绝对值大于1
        if left-right > 1 or left - right < -1:
            return False
         # 否则，判断左右子树是否平衡
        return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
```



## 数组

### NC61 两数之和

找到数组里满足和为目标值的两数下标，返回下标升序。

- step 1：构建一个哈希表，其中key值为遍历数组过程中出现过的值，value值为其相应的下标，因为我们最终要返回的是下标。
- step 2：遍历数组每个元素，如果目标值减去该元素的结果在哈希表中存在，说明我们先前遍历的时候它出现过，根据记录的下标，就可以得到结果。
- step 3：如果相减后的结果没有在哈希表中，说明先前遍历的元素中没有它对应的另一个值，那我们将它加入哈希表，等待后续它匹配的那个值出现即可。
- step 4：需要注意最后的结果是下标值加1.

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param numbers int整型一维数组 
# @param target int整型 
# @return int整型一维数组
#
class Solution:
    def twoSum(self , numbers: List[int], target: int) -> List[int]:
        res = []
        # 创建哈希表，分别储存数组值和下标
        hash =  dict()
        # 在哈希表中查找target-numbers[i]
        for i in range(len(numbers)):
            temp = target - numbers[i]

            if temp not in hash:
                hash[numbers[i]] = i
            else:
                res.append(hash[temp] + 1)
                res.append(i + 1)
                break
        return res

```

### ♨️NC54 三数之和

拆分一下：如果找到了某个数a，要找到与之对应的另外两个数，三数之和为0，只要找到另外两个数之和为−a。

因为三元组内部必须是有序的，因此可以优先对原数组排序，这样每次取到一个最小的数为a，只需要在后续数组中找到两个之和为−a就可以了，可以用双指针缩小区间遍历。

注意要去除重复的三元组！！

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return int整型二维数组
#
class Solution:
    def threeSum(self , num: List[int]) -> List[List[int]]:
        res = list(list())
        n = len(num)
        if n < 3:
            return res
        num.sort() # 排序，默认升序，设置reverse=True可以降序排列
        for i in range(n-2):
            if i != 0 and num[i] == num[i-1]: # 之前相等的数字已经搜过了，解集中不能包含重复的三元组
                continue
            
            left = i+1
            right = n-1
            target = -num[i]
            while left < right:
                if  num[left] + num[right] == target:
                    res.append([num[i], num[left], num[right]])
                    # 已经添加了这个三元组，如果后续还有一样的，直接舍弃让指针移动
                    while left+1 < right and num[left] == num[left+1]:
                        left += 1
                    while right-1 < left and num[right] == num[right-1]:
                        right -= 1
                    #双指针向中间收缩
                    left += 1
                    right -= 1
                    
                elif num[left] + num[right] > target:
                    right -= 1
                else:
                    left += 1
        return res
```



### NC41 最长无重复子数组

滑动窗口，维护一个长度最大值。

- step 1：构建一个哈希表，用于统计数组元素出现的次数。
- step 2：窗口左右界都从0下标开始，每次窗口优先右移右界，并统计进入窗口的元素的出现频率。
- step 3：一旦右界元素出现频率大于1，就需要右移左界直到窗口内不再重复，将左边的元素移除窗口的时候同时需要将它在哈希表中的频率减1，保证哈希表中的频率都是窗口内的频率。
- step 4：每轮循环，维护窗口长度最大值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param arr int整型一维数组 the array
# @return int整型
#
class Solution:
    def maxLength(self , arr: List[int]) -> int:
        hash = dict()
        maxlen = 0
        left= 0

        for right in range(len(arr)):
            if arr[right] in hash:
                hash[arr[right]] += 1
            else:
                hash[arr[right]] = 1

            while hash[arr[right]] > 1:
                hash[arr[left]] -= 1
                left += 1
                
            maxlen = max(maxlen, right-left+1)
        return maxlen
```

### ⚡♨️NC91 最长上升子序列（三）

贪心+二分的解法，举例说明基本思路，假设数组arr为`[2, 3, 1, 2, 3]`，tmp数组里面存放递增子序列，maxlen数组里存放以元素i结尾的最大递增子序列长度，那么遍历数组arr并执行如下更新规则:

1. 初始情况下，tmp为[2]，maxLen[1]
2. 接下来遇到3，由于tmp最后一个元素小于3，直接更新，tmp为[2,3]，maxLen[1,2]
3. 接下来遇到1，由于tmp最后的元素大于1, 我们在tmp中二分查找大于等于1的第一个元素的下标，并用1替换之，此时tmp为[1,3], maxLen[1,2,1]
4. 接下来遇到2，由于tmp最后的元素大于2，我们在tmp中查找大于等于2的第一个元素的下标，并用2替换之，此时tmp为[1,2], maxLen[1,2,1,2]
5. 接下来遇到3，由于tmp最后一个元素小于3，直接更新，tmp为[1,2,3]，maxLen为[1,2,1,2,3]
6. 此时tmp的大小就是整个序列中最长递增子序列的长度（**但是tmp不一定是本题的最终解**）

------

对于第二步，假设我们原始数组是arr1，得到的maxLen为`[1,2,3,1,3]`，最终输出结果为res（字典序最小的最长递增子序列），res的最后一个元素在arr1中位置无庸置疑是`maxLen[i]==3`对应的下标，那么到底是`arr1[2]`还是`arr1[4]`呢？如果是`arr1[2]`，那么`arr1[2]<arr1[4]`，则`maxLen[4]==4`，与已知条件相悖。因此我们应该取`arr1[4]`放在res的最后一个位置。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# retrun the longest increasing subsequence
# @param arr int整型一维数组 the array
# @return int整型一维数组
#
class Solution:
    def LIS(self , arr: List[int]) -> List[int]:
        if len(arr) < 2:
            return arr
        
        self.index = None #构建二分查找，查找第一个比i大的元素位置
        def binary_find(arr, left, right, target):
            if left > right:
                return
            mid = int(left + (right - left) / 2)
            if arr[mid] >= target:
                self.index = mid
                return binary_find(arr, left, mid-1, target)
            elif arr[mid] < target:
                return binary_find(arr, mid+1, right, target)

        maxlen, tmp = [1],[arr[0]]
        for i in range(1,len(arr)):
            if arr[i] > tmp[-1]:
                tmp.append(arr[i])
                maxlen.append(len(tmp))
            else:
                binary_find(tmp, 0, len(tmp)-1, arr[i])
                tmp[self.index] = arr[i]
                maxlen.append(len(tmp[:self.index+1]))
        
        #找到了最大长度，但不一定是最终输出，所以读取manxlen里的长度把输出恢复
        length = len(tmp)
        for i in range(len(arr)-1, -1, -1): #倒序
            if maxlen[i] == length:
                tmp[length-1] = arr[i]
                length -= 1
        
        return tmp
```



### NC22 合并两个有序的数组

类似NC33合并有序链表，双指针。不同点在于本题是在数据A上面直接添加。因为数组A后半部分相当于为空，则可以考虑逆向使用归并排序思想，从较大的开始排。对于两个数组每次选取较大的值，因此需要使用两个同时向前遍历的双指针。

```
#
# 
# @param A int整型一维数组 
# @param B int整型一维数组 
# @return void
#
class Solution:
    def merge(self , A, m, B, n):
        pa = m-1
        pb = n-1
        k = m+n-1 #记录合并后A的储存位置

        while pa >= 0 and pb >= 0:
            if A[pa] > B[pb]:
                A[k] = A[pa]
                pa -= 1
                k -= 1
            else:
                A[k] = B[pb]
                pb -= 1
                k -= 1
        # 数组A遍历完了，数组B还有，则还需要添加到数组A前面
        if pa <0:
            while pb >= 0:
                A[k] = B[pb]
                pb -= 1
                k -= 1
        #数组B遍历完了，数组A前面正好有，不用再添加 
        
        return A
```

### NC38 螺旋矩阵

按照螺旋方向循环遍历数组。

<img src="/home/chuyun/Downloads/personal/Offer_log/nc38.png" style="zoom:70%;" />

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param matrix int整型二维数组 
# @return int整型一维数组
#
class Solution:
    def spiralOrder(self , matrix: List[List[int]]) -> List[int]:
        res = []
        n = len(matrix)
        if n == 0:
            return res
        # 定义边界
        left, up = 0, 0
        right = len(matrix[0])-1
        down = n -1
        # 直到左右或上下边界出现过重合
        while left <= right and up <= down:
            # 左->右
            for i in range(left, right + 1):
                res.append(matrix[up][i])
            up += 1
            if up > down:
                break
            # 上->下
            for i in range(up, down + 1):
                res.append(matrix[i][right])
            right -= 1
            if left > right:
                break
            # 右->左
            i = right
            while i >= left:
                res.append(matrix[down][i])
                i -= 1
            down -= 1
            if up > down:
                break
            # 下->上
            i = down
            while i >= up:
                res.append(matrix[i][left])
                i -= 1
            left += 1
            if left > right:
                break
        return res
```

### NC48 在旋转过的有序数组中寻找目标值

暴力遍历可以。还可以二分查找，时间复杂度从o(n)降到o(logn)。假设从left到k，k+1到right为两个有序部分，mid一定位于（left，k）（k+1，right）两个区间之内，那么（left，mid）和（mid，right）这两个区间必定有一个是有序的。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @param target int整型 
# @return int整型

class Solution:
    def search(self , nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        # 二分查找
        while left <= right:
            # mid = int((left+right)/2)会超时，因为left和right相加超过int表示的最大范围时就会溢出变为负数
            mid = int(left+(right-left)/2)
            if target == nums[mid]:
                return mid
            # left-mid 是有序数组
            elif nums[mid] >= nums[left]:
                if target < nums[mid] and target >= nums[left]:
                    right = mid -1
                else:
                    left = mid + 1
            # mid-right 是有序数组
            else:
                if target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid -1        
        # 没找到
        return -1
```

### NC7 买卖股票的最好时机(一)

贪心算法。

- step 1：首先排除数组为空的特殊情况。
- step 2：将第一天看成价格最低，后续遍历的时候遇到价格更低则更新价格最低。
- step 3：每次都比较最大收益与当日价格减去价格最低的值，选取最大值作为最大收益。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param prices int整型一维数组 
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        res = 0
        if len(prices) == 0:
            return res
        Min = prices[0] # 维护最低股票价格
        for i in range(1, len(prices)):
            Min = min(Min, prices[i])
            res = max(res, prices[i]-Min) # 维护最大收益
        return res
```

### ♨️NC128 接雨水问题

类似水桶的短板问题。设置两边为边界，双指针往中间扫描。具体：边界比较，短的边界先进行扫描，直到遇到了更大值，更新边界，重复上述过程。

<img src="/home/chuyun/Downloads/personal/Offer_log/nc128.gif" style="zoom:20%;" />

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# max water
# @param arr int整型一维数组 the array
# @return long长整型
#
class Solution:
    def maxWater(self , arr: List[int]) -> int:
        res = 0
        if len(arr) == 0:
            return res
        # 维护左右边界
        maxl, maxr = 0 ,0
        # 左右双指针(移动)
        left, right = 0, len(arr)-1

        while left < right:
            # 遇到更高的，更新边界
            maxl = max(maxl, arr[left])
            maxr = max(maxr, arr[right])
            # 较短的边界往中间走
            if maxl < maxr:
                res += maxl - arr[left]
                left += 1
            else:
                res += maxr - arr[right]
                right -= 1
        return res
```

### NC73 数组中出现次数超过一半的数字

可以用哈希表记录每个数字出现的次数，再找出众数，但超时。

第二种方法是投票法，思路是先找出众数候选者，然后再判断是否超一半。候选者由投票选出，如果是众数，那么与它相同的+1票，与它不同的-1票，那么最后它的票数一定大于0，也就是被留作候选者cond。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param numbers int整型一维数组 
# @return int整型
#

# # 空间复杂度o(n)
# class Solution:
#     def MoreThanHalfNum_Solution(self , numbers: List[int]) -> int:
#         #无序哈希表统计每个数字出现的次数
#         mp = dict() 
#         #遍历数组
#         for i in range(len(numbers)): 
#             if numbers[i] in mp:
#                 #哈希表中相应数字个数加1
#                 mp[numbers[i]] += 1  
#             else:
#                 mp[numbers[i]] = 1
#             #一旦有个数大于长度一半的情况即可返回
#             if mp[numbers[i]] > (int)(len(numbers) / 2): 
#                 return numbers[i]
#         return 0

# # 空间复杂度o(1) 投票法
class Solution:
    def MoreThanHalfNum_Solution(self , numbers: List[int]) -> int:
        cond = -1 # 候选元素
        ticket = 0 # 得票数
        for i in range(0, len(numbers)):
            # 还没有候选者
            if ticket == 0: 
                cond = numbers[i]
                ticket += 1
            else:
                if cond == numbers[i]:
                    ticket += 1
                else:
                    ticket -= 1
        
        ticket = 0
        # 最后剩下的就是可能的候选者，判断是否超了一半
        for i in range(0, len(numbers)):
            if cond == numbers[i]:
                ticket += 1
        if ticket > len(numbers)/2:
            return cond
        return 0
```



## 

## 栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

### NC76 用两个栈实现队列

借助栈的**先进后出**规则模拟实现队列的**先进先出**

1.插入时，直接插入 stack1

2.弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2 栈顶元素

```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []
    def push(self, node):
        self.stack1.append(node)
    def pop(self):
        if self.stack2 == []:
            while self.stack1:
                self.stack2.append(self.stack1.pop()) # pop()函数用于移除列表中的一个元素(默认为最后一个元素)
        return self.stack2.pop()
```

### NC90 包含min函数的栈

关键在于怎么用o(1)时间复杂度找到min。

- step 1：使用一个栈记录进入栈的元素，正常进行push、pop、top操作。
- step 2：使用另一个栈记录每次push进入的最小值。
- step 3：每次push元素的时候与第二个栈的栈顶元素比较，若是较小，则进入第二个栈，若是较大，则第二个栈的栈顶元素再次入栈，因为即便加了一个元素，它依然是最小值。于是，每次访问最小值即访问第二个栈的栈顶。

```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.s1 = []
        self.s2 = []
        
    def push(self, node):
        self.s1.append(node)
        #空或者新元素较小，则入栈
        if len(self.s2) ==0 or node < self.s2[-1]:
            self.s2.append(node)
        else:
            #重复加入栈顶，为什么不是只维护一个最小值，因为那样pop后容易丢掉下一个最小值
            self.s2.append(self.s2[-1])
    def pop(self):
        self.s1.pop()
        self.s2.pop()
    def top(self):
        return self.s1[-1]
    def min(self):
        return self.s2[-1]
```



## 

## 动态规划

动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果。

### NC65 斐波那契数列

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 
# @return int整型
#
class Solution:
    def Fibonacci(self , n: int) -> int:
        
        # res = 1
        # if n > 2:
        #     res = self.Fibonacci(n-1) + self.Fibonacci(n-2)
        # return res
        # 会超时,时间复杂度：O(2^n)
        # 解决方法：由于F(n)只和F(n−1)与F(n−2)有关，因此只需要维护三个变量sum, a, b，使其交替更新。这样就把空间复杂度降至O(1)

        a, b, sum = 1, 1, 0
        if n <= 2:
            return 1
        for i in range(0, n-2):
            sum = a + b
            a = b
            b = sum
        return sum
```

### NC68 跳台阶

青蛙一次可以跳1阶或2阶，直到跳到第n阶，也可以看成这只青蛙从n阶往下跳，到0阶，按照原路返回的话，两种方法事实上可以的跳法是一样的——即怎么来的，怎么回去！ 当青蛙在第n阶往下跳，它可以选择跳1阶到n−1，也可以选择跳2阶到n−2，即它后续的跳法变成了f(n−1)+f(n−2)，这就变成了斐波那契数列。因此可以按照斐波那契数列的做法来做：**即输入n，输出第n个斐波那契数列的值**，初始化0阶有1种，1阶有1种。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param number int整型 
# @return int整型
#
class Solution:
    def jumpFloor(self , number: int) -> int:
        # 初始化第0和第1阶
        if number <= 1:
            return 1
        fn = 0
        fn_1 = 1
        fn_2 = 1
        for i in range(2, number+1):
            fn = fn_1 + fn_2
            fn_2 = fn_1 # 各自往前走一步
            fn_1 = fn
        return fn
```

### ♨️NC19 连续子数组的最大和

因为数组中有正有负有0，因此每次遇到一个数，要不要将其加入我们所求的连续子数组里面，是个问题，有可能加入了会更大，有可能加入了会更小，而且我们要求连续的最大值，因此这类有状态转移的问题可以考虑动态规划。

**具体做法：**

- step 1：可以用dp数组表示以下标i为终点的最大连续子数组和。
- step 2：遍历数组，每次遇到一个新的数组元素，**连续的子数组要么加上变得更大，要么这个元素本身就更大，要么会更小，更小我们就舍弃，因此状态转移为dp[i] = max( dp[i−1] + array[i], array[i] )**。
- step 3：因为连续数组可能会断掉，每一段只能得到该段最大值，因此我们需要维护一个最大值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param array int整型一维数组 
# @return int整型
#
class Solution:
    def FindGreatestSumOfSubArray(self , array: List[int]) -> int:
        dp = [0 for i in range(len(array))]
        dp[0] = array[0]
        maxsum = dp[0]
        for i in range(1, len(array)):
            dp[i] = max(dp[i-1] + array[i], array[i])
            maxsum = max(maxsum, dp[i])
        return maxsum
```

### ♨️NC59 矩阵的最小路径和

- step 1：构造一个与矩阵同样大小的二维辅助数组，其中dp[i, j]表示以(i, j)位置为终点的最短路径和，dp[0, 0]=matrix[][0][0, 0] 。
- step 2：第一行与第一列只能分别向右或向下，没有第二种选择，因此dp矩阵第一行和第一列的值可以直接确定。
- step 3：边缘状态构造好以后，遍历矩阵，补全矩阵中每个位置的dp数组值：如果当前的位置是(i，j)，上一步要么是(i−1, j)往下，要么就是(i, j−1)往右，那么取其中较小值与当前位置的值相加就是到当前位置的最小路径和，因此状态转移公式为**dp[i, j]=min( dp[i−1, j], dp[i, j−1] ) + matrix[i, j]**。
- step 4：最后，dp(n−1,m−1)的值就是要求的最短路径和。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param matrix int整型二维数组 the matrix
# @return int整型
#
class Solution:
    def minPathSum(self , matrix: List[List[int]]) -> int:
        n = len(matrix)
        m = len(matrix[0])
        dp = [[0] * m for i in range(n)]
        dp[0][0] = matrix[0][0]
        # dp矩阵填充边界
        for i in range(1, n):
            dp[i][0] = dp[i-1][0] + matrix[i][0]
        for i in range(1, m):
            dp[0][i] = dp[0][i-1] + matrix[0][i]
        # 按照转移公式填充矩阵
        for i in range(1, n):
            for j in range(1, m):
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]
        return dp[n-1][m-1]
```



## 基础数学运算

### NC32 求平方根

在1～x范围内进行**二分查找**。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param x int整型 
# @return int整型
#
class Solution:
    def sqrt(self , x: int) -> int:
        if x <= 1:
            return x
        
        left, right = 1, x
        while(left <= right):
            mid = int((left+right)/2)
            if mid*mid <= x and (mid+1)*(mid+1) > x: # 注意这里第二个是大于，不然类似求9的平方根时会漏掉真实答案
                return mid
            elif mid*mid >= x:
                right = mid-1
            else:
                left = mid+1
        return mid
```

## 搜索（dfs，bfs）

### ♨️NC109 岛屿数量

矩阵中多处聚集着1，要想统计1聚集的堆数而不重复统计，那可以考虑每次找到一堆相邻的1，就将其全部改成0，而将所有相邻的1改成0的步骤又可以使用深度优先搜索**（dfs）**：当遇到矩阵的某个元素为1时，首先将其置为了0，然后查看与它相邻的上下左右四个方向，如果这四个方向任意相邻元素为1，则进入该元素，进入该元素之后我们发现又回到了刚刚的子问题，又是把这一片相邻区域的1全部置为0，因此可以用递归实现。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 判断岛屿数量
# @param grid char字符型二维数组 
# @return int整型


class Solution:
    #深度优先遍历与i，j相邻的所有1
    def dfs(self, grid:List[List[str]], i:int, j:int) : 
        n = len(grid)
        m = len(grid[0])
        #置为0
        grid[i][j] = '0' 
        #后续四个方向遍历
        if i - 1 >= 0 and grid[i - 1][j] == '1':
            self.dfs(grid, i - 1, j)
        if i + 1 < n and grid[i + 1][j] == '1':
            self.dfs(grid, i + 1, j)
        if j - 1 >= 0 and grid[i][j - 1] == '1':
            self.dfs(grid, i, j - 1)
        if j + 1 < m and grid[i][j + 1] == '1':
            self.dfs(grid, i, j + 1)
            
    def solve(self , grid: List[List[str]]) -> int:
        n = len(grid)
        m = len(grid[0])
        #记录岛屿数
        res = 0 
        if  n == 0: 
            return res
               
        #遍历矩阵
        for i in range(n): 
            for j in range(m):
                if grid[i][j] == '1': 
                    res += 1 
                    # 用bfs将与它相邻的所有1置为0
                    self.dfs(grid, i, j) 
        return res
```

